// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: sse_token.sql

package queries

import (
	"context"
)

const identifyUserFromSseToken = `-- name: IdentifyUserFromSseToken :one
select
    sse_token.twitch_user_id
from ledger.sse_token
where sse_token.value = $1
    and sse_token.expires_at > now()
limit 1
`

func (q *Queries) IdentifyUserFromSseToken(ctx context.Context, tokenValue string) (string, error) {
	row := q.db.QueryRowContext(ctx, identifyUserFromSseToken, tokenValue)
	var twitch_user_id string
	err := row.Scan(&twitch_user_id)
	return twitch_user_id, err
}

const purgeSseTokensForUser = `-- name: PurgeSseTokensForUser :exec
delete from ledger.sse_token
where sse_token.twitch_user_id = $1
    and sse_token.expires_at <= now()
`

func (q *Queries) PurgeSseTokensForUser(ctx context.Context, twitchUserID string) error {
	_, err := q.db.ExecContext(ctx, purgeSseTokensForUser, twitchUserID)
	return err
}

const storeSseToken = `-- name: StoreSseToken :exec
insert into ledger.sse_token (
    twitch_user_id,
    value,
    expires_at
) values (
    $1,
    $2,
    now() + (($3::int)::text || 's')::interval
)
`

type StoreSseTokenParams struct {
	TwitchUserID string
	TokenValue   string
	TtlSeconds   int32
}

func (q *Queries) StoreSseToken(ctx context.Context, arg StoreSseTokenParams) error {
	_, err := q.db.ExecContext(ctx, storeSseToken, arg.TwitchUserID, arg.TokenValue, arg.TtlSeconds)
	return err
}
